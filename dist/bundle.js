/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/animation.js":
/*!**************************!*\
  !*** ./src/animation.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Animation)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// 我放棄掙扎了，可能是webpack的設定有問題，我必須在html導入所需的模組網址才能將spotlight顯示，我不懂為什麼\n// import * as THREE from 'three';\nvar Animation = /*#__PURE__*/function () {\n  function Animation(canvas) {\n    var _this = this;\n    _classCallCheck(this, Animation);\n    this.requestID;\n    this.scene = new THREE.Scene(); // 建立場景\n    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); // 設置鏡頭\n    // this.renderer = new THREE.WebGLRenderer(); // 建立渲染器\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: true\n    }); // 建立渲染器，啟用透明背景，沒用\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    // this.renderer.setClearColor('#000000'); // 背景色設置為黑色\n    this.renderer.setClearColor(0x000000, 0); // 背景色設置為透明\n    this.renderer.shadowMap.enabled = true;\n    this.camera.position.set(0, 0, 20); // 移動相機的Z軸\n\n    this.ambientLight = new THREE.AmbientLight('#ffffff', 0.4); // 建立環境光，數字越小光線越弱\n    this.scene.add(this.ambientLight);\n\n    // 設定聚光燈的位置和屬性\n    this.spotLight = new THREE.SpotLight('#ffffff'); // 建立聚光燈\n    this.spotLight.position.set(20, 30, 20); // 將聚光燈移到愛心的右上角\n    this.spotLight.angle = Math.PI / 20; // 調整聚光燈的角度，使其更聚光燈\n    this.spotLight.penumbra = 1.0; // 調整聚光燈的半影，讓光線更柔和\n    this.scene.add(this.spotLight);\n\n    // 幫助查看聚光燈路線\n    // const spotLightHelper = new THREE.SpotLightHelper(this.spotLight);\n    // this.scene.add(spotLightHelper);\n\n    this.canvas = canvas;\n    this.infoElement = document.createElement('div');\n    this.infoElement.innerText = '>   press SPACE to continue   <';\n    this.infoElement.style.position = 'absolute';\n    this.infoElement.style.top = '50%';\n    this.infoElement.style.left = '50%';\n    this.infoElement.style.transform = 'translate(-50%, -50%)';\n    this.infoElement.style.fontFamily = 'Cubic_11';\n    this.infoElement.style.color = 'white';\n    this.infoElement.style.fontSize = '24px';\n    this.infoElement.style.textShadow = /* White glow */\n    '0 0 7px white', '0 0 10px white', '0 0 21px white', /* Green glow */\n    '0 0 42px red', '0 0 82px red', '0 0 92px red', '0 0 102px red', '0 0 151px red';\n    this.infoElement.style.display = 'block';\n    this.opening = new Audio('sound/opening.mp3');\n    this.opening.loop = false;\n    this.opening.volume = 0.8;\n\n    // 初始化 keyPressed\n    this.keyPressed = {};\n    document.body.addEventListener('keydown', function (event) {\n      _this.keyPressed[event.key] = true;\n    });\n    document.body.addEventListener('keyup', function (event) {\n      _this.keyPressed[event.key] = false;\n    });\n  }\n  return _createClass(Animation, [{\n    key: \"createHeartAnimation\",\n    value: function createHeartAnimation(onComplete) {\n      var _this2 = this;\n      this.append();\n      this.heartPixels = [[0, 0, 3, 5, 5, 3, 0, 0, 0, 0, 0, 3, 5, 5, 3, 0, 0], [0, 3, 7, 7, 7, 7, 5, 0, 0, 0, 5, 7, 7, 7, 7, 3, 0], [3, 5, 7, 7, 7, 9, 9, 5, 0, 5, 9, 9, 7, 7, 7, 5, 3], [3, 5, 7, 7, 7, 9, 9, 9, 3, 9, 9, 9, 7, 7, 7, 5, 3], [3, 5, 7, 7, 7, 7, 9, 9, 9, 9, 9, 7, 7, 7, 7, 5, 3], [3, 5, 5, 5, 7, 7, 7, 9, 9, 9, 7, 7, 7, 5, 5, 5, 3], [1, 3, 5, 5, 5, 7, 7, 7, 9, 7, 7, 7, 5, 5, 5, 3, 1], [1, 3, 3, 3, 5, 5, 7, 7, 7, 7, 7, 5, 5, 3, 3, 3, 1], [0, 1, 1, 3, 3, 5, 5, 7, 7, 7, 5, 5, 3, 3, 1, 1, 0], [0, 0, 1, 1, 3, 3, 5, 5, 7, 5, 5, 3, 3, 1, 1, 0, 0], [0, 0, 0, 1, 1, 3, 3, 5, 5, 5, 3, 3, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 3, 3, 5, 3, 3, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 3, 3, 3, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 3, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]];\n      this.centerX = this.heartPixels[0].length / 2;\n      this.centerY = this.heartPixels.length / 2;\n      this.geometry = new THREE.BoxGeometry(1, 1, 1);\n      this.material = new THREE.MeshPhongMaterial({\n        color: '#FF0000'\n      });\n      // this.material = new THREE.MeshLambertMaterial({ color: '#FF0000' });\n      this.numCube = 0;\n\n      // 建立一個群組來包含所有的立方體\n      this.heartGroup = new THREE.Group();\n      for (this.y = 0; this.y < this.heartPixels.length; this.y++) {\n        for (this.x = 0; this.x < this.heartPixels[this.y].length; this.x++) {\n          this.centerZ = this.heartPixels[this.y][this.x] / 2;\n          // 實心的885 -> 缺點東西362 -> 空心的472\n          for (this.z = 0; this.z < this.heartPixels[this.y][this.x]; this.z++) {\n            if (this.y === 0 || this.y >= 1 && this.heartPixels[this.y][this.x] > this.heartPixels[this.y - 1][this.x] && (this.z <= (this.heartPixels[this.y][this.x] - this.heartPixels[this.y - 1][this.x]) / 2 || this.z >= (this.heartPixels[this.y][this.x] - 1 - this.heartPixels[this.y][this.x] - this.heartPixels[this.y - 1][this.x]) / 2) || this.x === 0 || this.x === this.heartPixels[this.y].length - 1 || this.z === 0 || this.z === this.heartPixels[this.y][this.x] - 1) {\n              this.cube = new THREE.Mesh(this.geometry, this.material);\n              this.cube.position.set(this.centerX - this.x, this.centerY - this.y, this.centerZ - this.z);\n              this.heartGroup.add(this.cube);\n              this.numCube += 1;\n            }\n          }\n        }\n      }\n      this.scene.add(this.heartGroup); // 將群組加入場景\n      // console.log(this.numCube);\n      // console.log(this.scene.children);\n\n      var animate = function animate() {\n        _this2.requestID = requestAnimationFrame(animate);\n        _this2.heartGroup.rotation.y += 0.03; // 更新群組的旋轉角度\n\n        // 計算螢幕上的大小\n        var box = new THREE.Box3().setFromObject(_this2.heartGroup);\n        var size = new THREE.Vector3();\n        box.getSize(size);\n        var distance = _this2.camera.position.distanceTo(_this2.heartGroup.position);\n        var vFOV = _this2.camera.fov * Math.PI / 180; // 角度到弧度的轉換\n        var height = 2 * Math.tan(vFOV / 2) * distance; // visible height\n        var heightInPixels = window.innerHeight;\n        var worldToPixels = heightInPixels / height;\n        var targetSizeInPixels = 50; // 目標大小（50像素）\n        var sizeInPixels = size.x * worldToPixels;\n        _this2.renderer.render(_this2.scene, _this2.camera); // 渲染場景與鏡頭 \n\n        if (_this2.keyPressed[' ']) {\n          // this.infoElement.style.display = 'none';\n          _this2.opening.play();\n          _this2.heartGroup.scale.multiplyScalar(0.99); // 縮小愛心\n\n          if (sizeInPixels <= targetSizeInPixels) {\n            // console.log(sizeInPixels, targetSizeInPixels);\n            cancelAnimationFrame(_this2.requestID);\n            _this2.remove();\n            onComplete();\n          }\n        }\n      };\n      this.requestID = animate();\n    }\n  }, {\n    key: \"append\",\n    value: function append() {\n      document.body.appendChild(this.renderer.domElement);\n      document.body.appendChild(this.infoElement);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      document.body.removeChild(this.renderer.domElement);\n      document.body.removeChild(this.infoElement);\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack:///./src/animation.js?");

/***/ }),

/***/ "./src/attack.js":
/*!***********************!*\
  !*** ./src/attack.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Attack)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Attack = /*#__PURE__*/function () {\n  function Attack(canvas, ctx, mode) {\n    _classCallCheck(this, Attack);\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.mode = mode;\n    this.radius = 0;\n    this.width = 0;\n    this.height = 0;\n    this.xs_mode2 = [];\n    this.random();\n  }\n  return _createClass(Attack, [{\n    key: \"random\",\n    value: function random() {\n      // console.log(\"random \" + `${this.mode}`);\n      if (this.mode === 'mode1') return this.randomMode1();else if (this.mode === 'mode2') return this.randomMode2();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      // console.log(\"draw \" + `${this.mode}`);\n      if (this.mode === 'mode1') this.drawMode1();else if (this.mode === 'mode2') this.drawMode2();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.mode === 'mode1') return this.updateMode1();else if (this.mode === 'mode2') return this.updateMode2();else return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"checkMode\",\n    value: function checkMode(mode) {\n      // console.log(\"checkMode \" + `${this.mode}`);\n      this.tmp = this.mode;\n      this.mode = mode;\n      if (this.tmp !== this.mode) this.random();\n    }\n  }, {\n    key: \"randomMode1\",\n    value: function randomMode1() {\n      // console.log(\"randomMode1\");\n      function isInsideSquare(canvas, x, y, radius) {\n        var squareLeft = (canvas.width - 300) / 2;\n        var squareRight = squareLeft + 300;\n        var squareTop = (canvas.height - 300) / 2;\n        var squareBottom = squareTop + 300;\n        return x - radius > squareLeft && x + radius < squareRight && y - radius > squareTop && y + radius < squareBottom;\n      }\n\n      // 隨機生成位置\n      do {\n        this.x = Math.random() * this.canvas.width;\n        this.y = Math.random() * this.canvas.height;\n        this.radius = Math.random() * 15 + 5;\n      } while (isInsideSquare(this.canvas, this.x, this.y, this.radius));\n\n      // 計算方向向量，朝向方框的中心移動\n      this.dx = this.canvas.width / 2 - this.x;\n      this.dy = this.canvas.height / 2 - this.y;\n      this.distanceToCenter = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\n      this.angle = Math.atan2(this.dy, this.dx);\n      this.speedMagnitude = Math.random() * 7 + 1; // 速度大小為 1 到 8\n\n      // 如果圓心到方框中心的距離小於一定值，則加上一個倍率以確保它遠離方框\n      if (this.distanceToCenter < 150) this.speedMagnitude *= 1.5;\n      this.speed = {\n        x: Math.cos(this.angle) * this.speedMagnitude,\n        y: Math.sin(this.angle) * this.speedMagnitude\n      };\n    }\n  }, {\n    key: \"drawMode1\",\n    value: function drawMode1() {\n      this.ctx.beginPath();\n      this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n      this.ctx.fillStyle = 'white';\n      this.ctx.fill();\n    }\n  }, {\n    key: \"updateMode1\",\n    value: function updateMode1() {\n      // if (this.radius === 0) this.random();\n      // 移動攻擊物件\n      this.x += this.speed.x;\n      this.y += this.speed.y;\n\n      // 檢查是否超出畫面範圍，若是則重新設定位置\n      if (this.x - this.radius > this.canvas.width || this.x + this.radius < 0 || this.y - this.radius > this.canvas.height || this.y + this.radius < 0) {\n        this.random();\n      }\n      return {\n        x: this.x,\n        y: this.y,\n        radius: this.radius\n      };\n    }\n  }, {\n    key: \"randomMode2\",\n    value: function randomMode2() {\n      var bottomLife = (this.canvas.height + 300) / 2 - 50;\n      var topLife = (this.canvas.height - 300) / 2 + 50;\n      this.width = 50;\n      this.fx = Math.random() * (this.canvas.width - 600) / 2;\n      // 還要調整，讓x不會擠在一起，得給玩家活著的可能\n      this.x = Math.random() * (this.canvas.width - 600) / 2 + (this.canvas.width + 600) / 2;\n      this.height = Math.random() * 50 + 200;\n      do {\n        this.y = Math.random() * this.canvas.height;\n        // console.log(\"大於\", topLife, \"或 小於\", bottomLife);\n        // console.log(\"random : \", this.y, this.y + this.height);\n      } while (this.y > (this.canvas.height + 300) / 2 || this.y + this.height < (this.canvas.height - 300) / 2 || !(topLife > this.y || bottomLife < this.y + this.height)); // 重複的條件\n    }\n  }, {\n    key: \"drawMode2\",\n    value: function drawMode2() {\n      // console.log(\"drawMode2\");\n      this.ctx.beginPath();\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillRect(this.x, this.y, this.width, this.height);\n    }\n  }, {\n    key: \"updateMode2\",\n    value: function updateMode2() {\n      // console.log(\"updateMode2\");\n      this.speed = 2;\n      this.x -= this.speed;\n\n      // 檢查是否超出畫面範圍，若是則重新設定位置\n      if (this.x + this.width < this.fx) {\n        this.random();\n      }\n      return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height\n      };\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack:///./src/attack.js?");

/***/ }),

/***/ "./src/heart.js":
/*!**********************!*\
  !*** ./src/heart.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Heart)\n/* harmony export */ });\n/* harmony import */ var _square_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./square.js */ \"./src/square.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Heart = /*#__PURE__*/function () {\n  function Heart(canvas, ctx, mode, img1, img2, img3) {\n    var _this = this;\n    _classCallCheck(this, Heart);\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.mode = mode;\n    this.x = (this.canvas.width - 50) / 2;\n    this.y = (this.canvas.height - 50) / 2;\n    this.speed = 5;\n    this.width = 50;\n    this.height = 50;\n    this.img1 = img1;\n    this.img2 = img2;\n    this.img3 = img3;\n    this.life = 3;\n    this.s = new _square_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, ctx, mode);\n\n    // 初始化 keyPressed\n    this.keyPressed = {};\n    document.body.addEventListener('keydown', function (event) {\n      _this.keyPressed[event.key] = true;\n    });\n    document.body.addEventListener('keyup', function (event) {\n      _this.keyPressed[event.key] = false;\n    });\n  }\n  return _createClass(Heart, [{\n    key: \"update\",\n    value: function update() {\n      var squareLeft = (this.canvas.width - this.s.rectWidth) / 2;\n      var squareRight = squareLeft + this.s.rectWidth;\n      var squareTop = (this.canvas.height - this.s.rectHeight) / 2;\n      var squareBottom = squareTop + this.s.rectHeight;\n      if ((this.keyPressed['w'] || this.keyPressed['ArrowUp']) && this.y > squareTop) this.y -= this.speed;else if ((this.keyPressed['s'] || this.keyPressed['ArrowDown']) && this.y < squareBottom - this.height) this.y += this.speed;\n      if ((this.keyPressed['a'] || this.keyPressed['ArrowLeft']) && this.x > squareLeft) this.x -= this.speed;else if ((this.keyPressed['d'] || this.keyPressed['ArrowRight']) && this.x < squareRight - this.width) this.x += this.speed;\n      return {\n        x: this.x + this.width / 2,\n        y: this.y + this.height / 2,\n        radius: this.width / 2\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      if (this.life == 2) this.ctx.drawImage(this.img2, this.x, this.y, this.width, this.height);else if (this.life == 1) this.ctx.drawImage(this.img3, this.x, this.y, this.width, this.height);else this.ctx.drawImage(this.img1, this.x, this.y, this.width, this.height);\n    }\n  }, {\n    key: \"checkMode\",\n    value: function checkMode(mode) {\n      this.tmp = this.mode;\n      this.mode = mode;\n      if (this.tmp !== this.mode) {\n        this.x = (this.canvas.width - 50) / 2;\n        this.y = (this.canvas.height - 50) / 2;\n      }\n      this.s.checkMode(mode, false);\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack:///./src/heart.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modeSwitch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modeSwitch.js */ \"./src/modeSwitch.js\");\n/* harmony import */ var _heart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./heart.js */ \"./src/heart.js\");\n/* harmony import */ var _square_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./square.js */ \"./src/square.js\");\n/* harmony import */ var _attack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attack.js */ \"./src/attack.js\");\n/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./animation.js */ \"./src/animation.js\");\n/* \r\n必須改進:\r\n1.長條形攻擊目前沒有碰撞就不會重新生成，且生成位置希望是連續不斷但又能躲過去的，最好是可以越來越快\r\n  目前會重新生成了，但設定還有些問題，也還不會變快\r\n2.印象中在攻擊撞到小心心的時候會減速很多，有點怪\r\n  ㄟ，好像是沒有了，不知道為什麼\r\n3.沒有任何贏的方式，可以看要用計時還是什麼當作計分方式🤔；也不知道最後要有怎樣的畫面\r\n  用計時作為結束畫面，可能算是贏了(?\r\n4.小心心目前用score來計算被撞了幾次，但這樣感覺不太直覺、會以為是得分而不是扣血；而且小心心的變化只有3段，但現在有5條命\r\n  三條命遞減且改變數名為life\r\n5.init要再加上遊玩規則說明，可能放在小心心的上方背景(?)\r\n  上下加了三條，主要是遊玩方式，可能再看看有沒有別的要加的；遊戲過程也加上不能碰白色的了\r\n6.over的原因還沒寫上去，可能可以把寫上去的生命數去掉(有點醜)，而且該頁面可以再加一點文字比如\"You lose....\"之類的\r\n  有了\r\n7.現在重新開始的時候，第二局或第三局很大機率那顆切換mode的球球會突然不見，然後就沒了\r\n  我的長方形攻擊加上自動生成的功能了，但如果在長方形模式死亡，切換模式攻擊還是無法生成，我不知道為什麼\r\n  我知道了，因為我切換模式的那個東西不像其他東東一樣會確認模式、模式不同就重新生成，所以我讓它的半徑歸零，一旦半徑為零則重新生成\r\n\r\n期望改進:\r\n1.要加入開場動畫，預計用three.js讓一顆3D愛心放大旋轉一圈再旋轉著縮小回去\r\n  我加了，但有點怪，目前無法和原本的canvas接在一起\r\n2.要加入失敗動畫，預計用three.js讓我們的小心心放大裂開(然後我就不知道了)\r\n3.要加入切換模式動畫，讓框框的變化是連續的，等框框變化完才會開始攻擊\r\n  姑且算是可以，但只有兩個模式切換間能成功，而且變化結束會有奇妙的停頓，我不知道為什麼\r\n4.希望可以加入藍色攻擊(只要不動就可以不會扣血)\r\n5.Music按鍵可以再逗趣一點\r\n6.攻擊方式再還原(原作)一點 \r\n*/\n\n// 儲存變更方式是在\"D:\\tool\\workspace\\HTML\\WWW programing\\Project\"輸入\"npx webpack\"\n// 用 Go Server 執行會更方便，只要有儲存都會自動變更畫面\n\n\n\n\n\nvar canvas = document.getElementById('game');\nvar ctx = canvas.getContext('2d');\ncanvas.height = window.innerHeight;\ncanvas.width = window.innerWidth;\nvar img1 = new Image();\nimg1.src = 'images/LittleHeart1.png';\nvar img2 = new Image();\nimg2.src = 'images/LittleHeart2.png';\nvar img3 = new Image();\nimg3.src = 'images/LittleHeart3.png';\nvar gameMusic = new Audio('sound/bg.mp3'); // 創建音樂元素\ngameMusic.loop = true; // 設定音樂循環播放\ngameMusic.volume = 0.5;\nvar collidedSound = new Audio('sound/collides.mp3');\ncollidedSound.loop = false;\nvar collidedSound2 = new Audio('sound/collides2.mp3');\ncollidedSound2.loop = false;\nvar collided = false;\nvar attacks = [];\nvar startTime = null;\nvar drawTimer, recorder;\nvar state = false;\nvar init = true;\nvar over = false;\n\n//生成各種物件\nvar requestId;\nvar modeSwitch = new _modeSwitch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, ctx);\nvar heart = new _heart_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](canvas, ctx, modeSwitch.mode, img1, img2, img3);\nvar square = new _square_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](canvas, ctx, modeSwitch.mode);\nfor (var i = 0; i < 4; i++) {\n  attacks.push(new _attack_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](canvas, ctx, modeSwitch.mode)); // 各種需要改，Mode2問題很大:無法再生，各種重生攻擊的方式需要改\n}\nvar animation = new _animation_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](canvas);\n\n// 各種按鈕們\nvar start = function start() {\n  var rectWidth = 180;\n  var rectHeight = 90;\n  var x = (canvas.width - rectWidth) / 2;\n  var y = (canvas.height - rectHeight) / 7 * 6;\n  return {\n    x: x,\n    y: y,\n    width: rectWidth,\n    height: rectHeight\n  };\n};\nvar music = function music() {\n  var rectWidth = 120;\n  var rectHeight = 70;\n  var x = (canvas.width - rectWidth) / 11;\n  var y = (canvas.height - rectHeight) / 7;\n  return {\n    x: x,\n    y: y,\n    width: rectWidth,\n    height: rectHeight\n  };\n};\nvar restart = function restart() {\n  var rectWidth = 120;\n  var rectHeight = 60;\n  var x = (canvas.width - rectWidth) / 9 * 2;\n  var y = (canvas.height - rectHeight) / 2;\n  return {\n    x: x,\n    y: y,\n    width: rectWidth,\n    height: rectHeight\n  };\n};\nvar home = function home() {\n  var rectWidth = 120;\n  var rectHeight = 60;\n  var x = (canvas.width - rectWidth) / 9 * 7;\n  var y = (canvas.height - rectHeight) / 2;\n  return {\n    x: x,\n    y: y,\n    width: rectWidth,\n    height: rectHeight\n  };\n};\n\n// 遊戲前的小動畫\nanimation.createHeartAnimation(onHeartAnimationComplete); // 呼叫建立心形動畫的函數\nfunction onHeartAnimationComplete() {\n  // console.log('createHeartAnimation is Completed.');\n  requestId = requestAnimationFrame(gameLoop); //  迴圈開始的入口\n}\n\n// 遊戲迴圈\nfunction gameLoop() {\n  clearCanvas(canvas);\n  if (init) beforeStart();\n  if (over) isOver();\n  if (modeSwitch.mode !== 'mode0') {\n    if (heart.life === 0) {\n      over = true;\n    }\n    square.checkMode(modeSwitch.mode, true);\n    heart.checkMode(modeSwitch.mode);\n    attacks.forEach(function (attack, index) {\n      attack.checkMode(modeSwitch.mode);\n    });\n    // checkAllAttacks(attacks, modeSwitch.mode); // 試圖藉由他們分開檢查狀態來讓它們可以在不同時間生成，讓它們分散，但JS是非同步，沒辦法，算了\n\n    if (square.animationStartTime === null) {\n      // console.log(collided);\n      attacks.forEach(function (attack, index) {\n        if (!collided && collide(modeSwitch.mode, attack.update(), heart.update())) {\n          heart.life--;\n          attacks.splice(index, 1);\n          attack.xs_mode2 = []; // 删除相同索引位置的 x 坐标\n          attacks.push(new _attack_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](canvas, ctx, modeSwitch.mode)); // 看能不能改一下，換成重複利用的方式生成，比如撞到或是超出界線之後重新random出初始位置\n          collided = true;\n          collidedSound.play();\n        }\n      });\n      if (!collided && collide(modeSwitch.mode, modeSwitch.update(), heart.update())) {\n        modeSwitch[\"switch\"]();\n        collided = true;\n        collidedSound2.play();\n      }\n      if (collided) collided = false; // 重置碰撞狀態\n    }\n    square.draw();\n    heart.draw();\n    modeSwitch.draw();\n    attacks.forEach(function (attack, index) {\n      attack.draw();\n    });\n    drawLife();\n    recorder = drawTimer();\n  }\n  requestId = requestAnimationFrame(gameLoop);\n}\nfunction beforeStart() {\n  var s = start();\n  var m = music();\n  if (collide(modeSwitch.mode, s, heart.update())) {\n    modeSwitch.mode = 'mode1';\n    modeSwitch.radius = 0;\n    init = false;\n    startTime = Date.now();\n    drawTimer = timer(startTime);\n  }\n  if (!collided && collide(modeSwitch.mode, m, heart.update())) {\n    collided = true;\n    if (!state) {\n      state = true;\n      gameMusic.play();\n    } else {\n      state = false;\n      gameMusic.pause();\n    }\n  } else if (collided && !collide(modeSwitch.mode, m, heart.update())) collided = false;\n  ctx.fillStyle = \"white\";\n  ctx.font = \"30px Cubic_11\";\n  ctx.fillText(\"Press ↑↓←→ or WASD to Move\", canvas.width / 2, canvas.height / 8 * 2);\n  ctx.fillText(\"Touch the Frame to Choose the Bottom\", canvas.width / 2, canvas.height / 8 * 3);\n  ctx.fillText(\"You have THREE lives....\", canvas.width / 2, canvas.height / 8 * 5);\n  drawButton(s, 'Start', true);\n  drawButton(m, 'Music', state);\n  heart.draw();\n}\nfunction drawButton(button, text, state) {\n  ctx.beginPath();\n  ctx.strokeStyle = 'white';\n  ctx.lineWidth = 5;\n  ctx.strokeRect(button.x, button.y, button.width, button.height);\n\n  // 設置字體大小和樣式\n  ctx.font = '30px Cubic_11';\n  ctx.fillStyle = 'white';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(text, button.x + button.width / 2, button.y + button.height / 2);\n  if (!state) {\n    // 在方框上加上左上斜到右下的紅色直線\n    ctx.beginPath();\n    ctx.strokeStyle = 'red'; // 設置線條顏色為紅色\n    ctx.lineWidth = 5; // 設置線條寬度\n    ctx.moveTo(button.x - 10, button.y - 10); // 將路徑移動到方框的左上角\n    ctx.lineTo(button.x + button.width + 10, button.y + button.height + 10); // 繪製直線到方框的右下角\n    ctx.stroke(); // 繪製線條\n  }\n}\nfunction isOver() {\n  // 輸了的結果畫面\n  var r = restart();\n  var h = home();\n  heart.life = 3;\n  modeSwitch.mode = 'mode0';\n  modeSwitch.radius = 0;\n  square.checkMode(modeSwitch.mode, true);\n  heart.checkMode(modeSwitch.mode);\n  attacks.forEach(function (attack, index) {\n    attack.checkMode(modeSwitch.mode);\n  });\n  square.animationStartTime = null;\n  // console.log(\"set null\");\n  // 上面這東東好像沒用\n\n  // 要補上小心心裂成兩半的動畫\n\n  ctx.font = '60px Cubic_11';\n  ctx.fillStyle = 'white';\n  ctx.fillText(recorder, canvas.width / 2, canvas.height / 9 * 3);\n  ctx.font = '60px Cubic_11';\n  ctx.fillStyle = 'white';\n  ctx.fillText(\"You lose....\", canvas.width / 2, canvas.height / 9 * 6);\n  if (collide(modeSwitch.mode, r, heart.update())) {\n    over = false;\n    modeSwitch.mode = 'mode1';\n    startTime = Date.now();\n    drawTimer = timer(startTime);\n  } else if (collide(modeSwitch.mode, h, heart.update())) {\n    over = false;\n    init = true;\n  }\n  drawButton(r, 'Restart', true);\n  drawButton(h, 'Home', true);\n  heart.draw();\n}\nfunction clearCanvas(canvas) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\n// attack碰撞heart，後者一定是用圓形做判定\nfunction collide(mode, itemA, itemB) {\n  // console.log(\"mode:\", mode);\n  // console.log(\"Item A:\", itemA);\n  // console.log(\"Item B:\", itemB);\n  var dx, dy;\n  if (mode === 'mode1') {\n    dx = itemA.x - itemB.x;\n    dy = itemA.y - itemB.y;\n    var distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < itemA.radius + itemB.radius;\n  } else if (mode === 'mode2' || mode === 'mode0') {\n    // 找出最接近的點\n    var closestX = clamp(itemB.x, itemA.x, itemA.x + itemA.width);\n    var closestY = clamp(itemB.y, itemA.y, itemA.y + itemA.height);\n\n    // 計算圓心和最接近點之間的距離\n    dx = itemB.x - closestX;\n    dy = itemB.y - closestY;\n\n    // 如果距離小於圓的半徑，則碰撞\n    return dx * dx + dy * dy <= itemB.radius * itemB.radius;\n  }\n\n  // 輔助函數，限制數值在範圍內\n  function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n  }\n}\nfunction drawLife() {\n  ctx.fillStyle = \"white\";\n  ctx.font = \"50px Cubic_11\";\n  ctx.fillText(recorder, canvas.width / 2, canvas.height / 9);\n  ctx.fillStyle = \"white\";\n  ctx.font = \"50px Cubic_11\";\n  ctx.fillText(\"life: \".concat(heart.life), canvas.width / 10, canvas.height / 9);\n}\n\n// 定義一個計時器函式，顯示從計時開始到現在的時間（包含毫秒）\nfunction timer(startTime) {\n  function padZero(num, length) {\n    var str = num.toString();\n    return str.padStart(length, '0');\n  }\n  function formatTime(minutes, seconds, milliseconds) {\n    return padZero(minutes, 2) + ':' + padZero(seconds, 2) + '.' + padZero(milliseconds, 3);\n  }\n  function getTimeElapsed() {\n    var currentTime = Date.now();\n    var elapsed = currentTime - startTime;\n    var milliseconds = Math.floor(elapsed % 1000);\n    var seconds = Math.floor(elapsed / 1000) % 60;\n    var minutes = Math.floor(elapsed / (1000 * 60));\n    return {\n      minutes: minutes,\n      seconds: seconds,\n      milliseconds: milliseconds\n    };\n  }\n  function update() {\n    var _getTimeElapsed = getTimeElapsed(),\n      minutes = _getTimeElapsed.minutes,\n      seconds = _getTimeElapsed.seconds,\n      milliseconds = _getTimeElapsed.milliseconds;\n    var formattedTime = formatTime(minutes, seconds, milliseconds);\n    return formattedTime;\n  }\n\n  // 返回更新函式，讓外部可以使用它來更新顯示\n  return update;\n}\n\n// function sleep(ms) {\n//     return new Promise(resolve => setTimeout(resolve, ms));\n// }\n// const checkAllAttacks = async (attacks, mode) => {\n//     for (let index = 0; index < attacks.length; index++) {\n//         let attack = attacks[index];\n//         attack.checkMode(mode);\n//         await sleep(300); // 每次迴圈之間等待300毫秒\n//     }\n// }\n\n// 啟用 HMR\nif (false) {}\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/modeSwitch.js":
/*!***************************!*\
  !*** ./src/modeSwitch.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ModeSwitch)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ModeSwitch = /*#__PURE__*/function () {\n  function ModeSwitch(canvas, ctx) {\n    _classCallCheck(this, ModeSwitch);\n    // console.log(\"Modeset\");\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.mode = 'mode0';\n    this.x = 0;\n    this.y = 0;\n    this.radius = 0;\n    // this.random();\n  }\n  return _createClass(ModeSwitch, [{\n    key: \"switch\",\n    value: function _switch() {\n      if (this.mode === 'mode1') this.mode = 'mode2';else if (this.mode === 'mode2') this.mode = 'mode1';\n      this.random();\n      this.draw();\n    }\n  }, {\n    key: \"random\",\n    value: function random() {\n      // console.log(\"random \" + `${this.mode}`);\n      if (this.mode === 'mode1') this.randomMode1();else if (this.mode === 'mode2') this.randomMode2();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      // console.log(\"draw \" + `${this.mode}`);\n      if (this.mode === 'mode1') this.drawMode1();else if (this.mode === 'mode2') this.drawMode2();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.mode === 'mode1') return this.updateMode1();else if (this.mode === 'mode2') return this.updateMode2();else return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"randomMode1\",\n    value: function randomMode1() {\n      // console.log(\"randomMode1\");\n      function isInsideSquare(canvas, x, y, radius) {\n        var squareLeft = (canvas.width - 300) / 2;\n        var squareRight = squareLeft + 300;\n        var squareTop = (canvas.height - 300) / 2;\n        var squareBottom = squareTop + 300;\n        return x - radius > squareLeft && x + radius < squareRight && y - radius > squareTop && y + radius < squareBottom;\n      }\n\n      // 隨機生成位置\n      do {\n        this.x = Math.random() * this.canvas.width;\n        this.y = Math.random() * this.canvas.height;\n        do {\n          this.radius = Math.random() * 200;\n        } while (this.radius < 5 || this.radius > 20);\n      } while (isInsideSquare(this.canvas, this.x, this.y, this.radius));\n\n      // 計算方向向量，朝向方框的中心移動\n      this.dx = this.canvas.width / 2 - this.x;\n      this.dy = this.canvas.height / 2 - this.y;\n      this.distanceToCenter = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\n      this.angle = Math.atan2(this.dy, this.dx);\n      this.speedMagnitude = Math.random() * 7 + 1; // 速度大小為 1 到 8\n\n      // 如果圓心到方框中心的距離小於一定值，則加上一個倍率以確保它遠離方框\n      if (this.distanceToCenter < 150) this.speedMagnitude *= 1.5;\n      this.speed = {\n        x: Math.cos(this.angle) * this.speedMagnitude,\n        y: Math.sin(this.angle) * this.speedMagnitude\n      };\n    }\n  }, {\n    key: \"drawMode1\",\n    value: function drawMode1() {\n      this.ctx.beginPath();\n      this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n      this.ctx.fillStyle = 'yellow';\n      this.ctx.fill();\n    }\n  }, {\n    key: \"updateMode1\",\n    value: function updateMode1() {\n      if (this.radius === 0) this.random();\n      // console.log(`${this.mode}`)\n      // 移動攻擊物件\n      this.x += this.speed.x;\n      this.y += this.speed.y;\n\n      // 檢查是否超出畫面範圍，若是則重新設定位置\n      if (this.x - this.radius > this.canvas.width || this.x + this.radius < 0 || this.y - this.radius > this.canvas.height || this.y + this.radius < 0) {\n        this.random();\n      }\n      return {\n        x: this.x,\n        y: this.y,\n        radius: this.radius\n      };\n    }\n  }, {\n    key: \"randomMode2\",\n    value: function randomMode2() {\n      // console.log(\"randomMode2\");\n      this.width = 50;\n      this.fx = Math.random() * (this.canvas.width - 600) / 2;\n      // 還要調整，讓x不會擠在一起，得給玩家活著的可能\n      this.x = Math.random() * (this.canvas.width - 600) / 2 + (this.canvas.width + 600) / 2;\n      this.height = Math.random() * 50 + 200;\n      do {\n        this.y = Math.random() * this.canvas.height;\n      } while (this.y > (this.canvas.height + 300) / 2 || this.y + this.height < (this.canvas.height - 300) / 2); // 重複的條件\n    }\n  }, {\n    key: \"drawMode2\",\n    value: function drawMode2() {\n      // console.log(\"drawMode2\");\n      this.ctx.beginPath();\n      this.ctx.fillStyle = 'yellow';\n      this.ctx.fillRect(this.x, this.y, this.width, this.height);\n    }\n  }, {\n    key: \"updateMode2\",\n    value: function updateMode2() {\n      // console.log(\"updateMode2\");\n      this.speed = 2;\n      this.x -= this.speed;\n\n      // 檢查是否超出畫面範圍，若是則重新設定位置\n      if (this.x + this.width < this.fx) {\n        this.random();\n      }\n      return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height\n      };\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack:///./src/modeSwitch.js?");

/***/ }),

/***/ "./src/square.js":
/*!***********************!*\
  !*** ./src/square.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Square)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Square = /*#__PURE__*/function () {\n  function Square(canvas, ctx, mode) {\n    _classCallCheck(this, Square);\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.mode = mode;\n    this.rectWidth = this.canvas.width; // 為了讓愛心可以滿屏跑\n    this.rectHeight = this.canvas.height;\n    this.animationDuration = 1000; // 動畫持續時間（毫秒）\n    this.animationStartTime = null;\n    this.mode = 'mode0';\n  }\n  return _createClass(Square, [{\n    key: \"draw\",\n    value: function draw() {\n      // 切換框框動畫\n      if (this.animationStartTime !== null) {\n        var timestamp = performance.now();\n        var progress = (timestamp - this.animationStartTime) / this.animationDuration;\n        if (progress < 1) {\n          this.rectWidth = this.startWidth + (this.targetWidth - this.startWidth) * progress;\n          this.rectHeight = this.startHeight + (this.targetHeight - this.startHeight) * progress;\n        } else {\n          // console.log(\"timestamp\", timestamp);\n          this.rectWidth = this.targetWidth;\n          this.rectHeight = this.targetHeight;\n          this.animationStartTime = null; // 動畫完成\n          // console.log(\"finish!\");\n        }\n      }\n\n      // 畫框框\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = 'white';\n      this.ctx.lineWidth = 5;\n      this.ctx.strokeRect((this.canvas.width - this.rectWidth) / 2, (this.canvas.height - this.rectHeight) / 2, this.rectWidth, this.rectHeight);\n      this.ctx.font = '30px Cubic_11';\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillText(\"Don't Touch those WHITE Stuff....\", this.canvas.width / 2, (this.canvas.height + 300) / 2 + 50);\n    }\n  }, {\n    key: \"checkMode\",\n    value: function checkMode(mode, animation) {\n      this.tmp = this.mode;\n      this.mode = mode;\n      this.startWidth = this.rectWidth;\n      this.startHeight = this.rectHeight;\n      if (this.mode === 'mode1') {\n        this.rectWidth = 300;\n        this.rectHeight = 300;\n      } else if (this.mode === 'mode2') {\n        this.rectWidth = 600;\n        this.rectHeight = 300;\n      }\n      this.targetWidth = this.rectWidth;\n      this.targetHeight = this.rectHeight;\n      if (animation && this.tmp !== this.mode) {\n        this.animationStartTime = performance.now(); // 開始動畫\n        // console.log(this.tmp, this.mode);\n        // console.log(\"start!\");\n        // console.log(\"animationStartTime\", this.animationStartTime);\n      }\n      if (this.mode === 'mode0') {\n        this.animationStartTime = null;\n        this.rectWidth = this.canvas.width;\n        this.rectHeight = this.canvas.height;\n      }\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack:///./src/square.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;